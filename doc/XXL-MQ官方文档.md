## 《分布式消息队列XXL-MQ》

[![Actions Status](https://github.com/xuxueli/xxl-mq/workflows/Java%20CI/badge.svg)](https://github.com/xuxueli/xxl-mq/actions)
[![Maven Central](https://img.shields.io/maven-central/v/com.xuxueli/xxl-mq-core)](https://central.sonatype.com/artifact/com.xuxueli/xxl-mq-core)
[![GitHub release](https://img.shields.io/github/release/xuxueli/xxl-mq.svg)](https://github.com/xuxueli/xxl-mq/releases)
[![GitHub stars](https://img.shields.io/github/stars/xuxueli/xxl-mq)](https://github.com/xuxueli/xxl-mq/)
[![Docker pulls](https://img.shields.io/docker/pulls/xuxueli/xxl-mq-admin)](https://hub.docker.com/r/xuxueli/xxl-mq-admin/)
[![License](https://img.shields.io/badge/license-GPLv3-blue.svg)](http://www.gnu.org/licenses/gpl-3.0.html)
[![donate](https://img.shields.io/badge/%24-donate-ff69b4.svg?style=flat-square)](https://www.xuxueli.com/page/donate.html)

[TOCM]

[TOC]

## 一、简介

### 1.1 概述
XXL-MQ是一个轻量级分布式消息队列，具备“轻量级、分布式、高吞吐（单机TPS 10W+）、海量消息（亿级）” 等特性，支持 “并行消息、串行消息、分片消息、广播消息、延迟消息、失败重试消息”多消息类型，现已开放源代码，开箱即用。

### 1.2 特性

- 1、简单易用: 一行代码即可发布一条消息，一行注解即可订阅一个消息主题，接入灵活方便；
- 2、轻量级: 除存储层（可选，支持MySQL/TiDB），无第三方依赖；部署及运维低成本、轻量级。 
- 3、水平扩展：得益于存算分离系统设计，消息中心为无状态服务；消息中心（Broker）及消费者（Client）均支持集群扩展部署，线形提升消息生产及吞吐能力；
- 4、高可用/HA：消息中心内置注册发现能力，支持Broker服务以及Topic消费者动态注册；消息中心与消费者单节点故障时，可自动摘除故障节点，实现消息吞吐及消费故障转移；
- 5、高吞吐：消息生产及消费链路进行批量、并行及异步系统设计，消息存储进行冷数据及时清理归档设计，实现消息高吞吐（Mysql存储单机吞吐1W；TiDB存储单机吞吐10W）。
- 6、海量消息：消息存储基于DB实现，支持Mysql、TiDB多存储介质；消息存储进行冷热设计，并滚动式清理归档，支持海量消息堆积（Mysql存储支持千万级；TiDB存储支持10亿级/理论无上限）。
- 7、存算分离：消息中心（Broker）设计为无状态服务，提供主题及消息控制台管理能力以及消息RPC服务能力，与消息存储层解耦；
- 8、跨语言/OpenAPI：提供语言无关的消息中心 OpenAPI（RESTFUL 格式），提供消息生产、拉取及消费等能力，实现多语言支持；
- 9、实时性：消息中心与消费者基于JsonRpc进行吞吐消费，支持毫秒级生产投递、秒级消费感知，延迟消息基于时间轮机制支持零延迟消费感知；
- 10、消息持久化：消息数据默认持久化存储，并支持Topic维度自定义清理归档策略，灵活控制消息数据滚动归档清理；
- 11、分区路由策略：针对消息数据进行分区并路由消费者，提供丰富路由策略，包括：Hash、轮询、随机、第一个、最后一个、广播；
- 12、归档策略：针对已消费完成数据滚动归档及清理，提供丰富归档策略，包括：归档保留7天、归档保留30天、归档保留90天、归档永久保留、不归档直接清理；
- 13、重试策略：针对消费失败消息，支持设置丰富重试策略，包括：固定间隔、线性间隔、随机间隔；
- 14、失败重试：针对消费失败消息，支持自定义重试次数、以及重试间隔基数，结合重试策略支持灵活消费失败重试，支持重试次数耗尽或者消费成功；
- 15、超时控制: 支持自定义消息超时时间，消息消费超时将会主动中断；
- 16、多消息类型: 
    - 并行消息：多个消费者并行消费数据，支持轮询或随机策略。适用于消息吞吐量较大的业务场景，如邮件发送、日志记录等。
    - 串行消息：同一时刻只有一个消费者消费数据，消息按照生产顺序FIFO串行消费。适用于有串行消费诉求的业务场景，如秒杀、抢单等场景；
    - 分片消息：支持根据业务参数进行Hash分片，相同分片的消息数据路由至同一个消费者FIFO串行消费，不同分片的消息数据路由至不同消费者并行执行。适用于有根据业务参数分片消费的业务场景，如短信发送，可实现同一个手机号（业务参数）的消息路由至单个消费者串行消息，同时全局消息分片并行消费。
    - 广播消息：消息发送后，广播发送给相关主题全部在线消费者。适用于广播消息场景，如广播通知、广播更新缓存等；
    - 延时消息：支持设置消息的延迟生效时间，到达设置的生效时间时该消息才会被消费。适用于延时消费场景，如订单超时取消、定时发送邮件等；
    - 失败重试消息：支持设置消息的失败重试次数，自定义重试间隔侧路，消息失败时会主动进行重试消费，直至重试次数耗尽或者消费成功。
- 17、消息可视化: 提供消息中心Web控制台，可在线管理消息主题、消息数据，查看消费数据及消费轨迹等；
- 18、消息轨迹: 消费生产及消费轨迹日志会进行记录，并支持在线查看，辅助排查业务问题；
- 19、优先级：支持设置消息主题优先级，优先级越高，消费吞吐资源配置及保障越高；
- 20、消息失败告警：支持以Topic粒度监控消息，存在失败消息时主动推送告警邮件；默认提供邮件方式失败告警，同时预留扩展接口，可方面的扩展短信、钉钉等告警方式；
- 21、容器化：提供官方Docker镜像，并实时更新推送DockerHub，进一步实现产品开箱即用；
- 22、访问令牌（AccessToken）：为提升系统安全性，消息中心和消费者客户端进行安全性校验，校验AccessToken合法性；


### 1.3 发展
于2015年中，我在github上创建XXL-MQ项目仓库并提交第一个commit，随之进行系统结构设计，UI选型，交互设计……

至今，XXL-MQ已接入多家公司的线上产品线，截止2016-09-18为止，XXL-MQ已接入的公司包括不限于：
    
	- 1、农信互联
    - 2、源源科技
	- ……

> 更多接入的公司，欢迎在 [登记地址](https://github.com/xuxueli/xxl-mq/issues/1 ) 登记，登记仅仅为了产品推广。

欢迎大家的关注和使用，XXL-MQ也将拥抱变化，持续发展。


#### Why MQ

- 1、**系统解耦**：生产者与消费者无需直接依赖，降低模块间耦合度，提升可维护性。  
- 2、**异步处理**：将耗时操作异步化，提高响应速度，增强用户体验。  
- 3、**削峰填谷**：缓解高并发请求对系统的冲击，防止系统雪崩。  
- 4、**保证最终一致性**：通过消息通知实现跨系统数据同步，支持重试机制确保一致性。  
- 5、**多通信模式诉求**：如点对点、发布订阅、延迟消息等，适应不同业务场景。  
- 6、**提高可靠性与容错能力**：消息持久化、失败重试、死信队列等机制保障消息不丢失。


#### Why XXL-MQ

Kafka、RabbitMQ等流行消息中间件，具备高吞吐及高性能等优势，但相对应的存在运维及搭建成本、高硬件资源消耗、依赖组件复杂度、冷启动成本等。如Kafka集群要求三节点部署、单独配置ZK（或启用KRaft）。

如果你期望 “轻量级、分布式、低运维成本、中等规模消息量级（TPS<10W；消息存储<10亿）”，轻量级分布式消息队列 XXL-MQ 是一个适合的解决方案，对比特征如下： 

- 1、**部署轻量级**：除存储层（可选，支持MySQL/TiDB），无第三方依赖；部署及运维低成本、轻量级。
- 2、**低运维成本**：可复用已有存储层基建能力，不需要额外运维；
- 3、**开发门槛低**：一行代码即可发布一条消息，一行注解即可订阅一个消息主题，接入灵活方便；
- 4、**特性丰富**：相较于传统消息中间件，具备丰富特性。详细参考章节 “1.2 特性”。
- 5、**二次开发**：系统基于流行语言及技术实现，可灵活进行二次开发，自定义扩展满足业务需求。


### 1.4 下载

#### 文档地址

- [中文文档](https://www.xuxueli.com/xxl-mq/)

#### 源码仓库地址

源码仓库地址 | Release Download
--- | ---
[https://github.com/xuxueli/xxl-mq](https://github.com/xuxueli/xxl-mq) | [Download](https://github.com/xuxueli/xxl-mq/releases)
[https://gitee.com/xuxueli0323/xxl-mq](https://gitee.com/xuxueli0323/xxl-mq) | [Download](https://gitee.com/xuxueli0323/xxl-mq/releases)  

#### 中央仓库地址

```
<!-- http://repo1.maven.org/maven2/com/xuxueli/xxl-mq-core/ -->
<dependency>
    <groupId>com.xuxueli</groupId>
    <artifactId>xxl-mq-core</artifactId>
    <version>{最新Release版本}</version>
</dependency>
```

#### 技术交流
- [社区交流](https://www.xuxueli.com/page/community.html)

### 1.5 环境

- Maven：3.9+
- Jdk：17+ (说明：版本1.5开始要求Jdk17；历史旧版本支持Jdk1.8)
- Mysql：8.0+

## 二、快速入门

### 2.1 初始化 "消息中心数据库" 
请下载项目源码并解压，获取 "消息中心数据库初始化SQL脚本" 并执行即可

"消息中心数据库初始化SQL脚本" 位置为:
```
/xxl-mq/doc/db/tables_xxl_mq.sql
``` 
消息中心支持集群部署，集群情况下各节点务必连接同一个mysql实例;

> 注意：消息中心数据库，原生兼容支持 "MySQL、TIDB" 两种存储方式，前者支持千万级消息堆积，后者支持10亿级别消息堆积（TIDB理论上无上限）；
> 可视情况选择使用，当选择TIDB时，仅需要修改消息中心数据库连接jdbc地址配置即可，其他部分如SQL和驱动兼容MySQL和TIDB使用，不需修改。


### 2.2 项目编译 
解压源码,按照maven格式将源码导入IDE, 使用maven进行编译即可，源码结构如下：

    - /xxl-mq-admin                     ：消息中心
    - /xxl-mq-core                      ：客户端 核心依赖, 提供API支持进行 消费生产 以及 消费者 开发；
    - /xxl-mq-samples                   ：接入项目参考示例, 可自行参考学习并使用；
        - /xxl-mq-samples-frameless     ：无框架示例项目，不依赖第三方框架，只需main方法即可启动运行；
        - /xxl-mq-samples-springboot    ：springboot版本示例项目；


### 2.3 “消息中心” 搭建

    消息中心项目：xxl-mq-admin
    作用：提供消息Broker、客户端注册能力，以及消息主题及消息在线管理等功能；

#### 步骤一：消息中心配置：
消息中心配置文件地址：

```
/xxl-mq/xxl-mq-admin/src/main/resources/application.properties
```

消息中心配置内容说明：

```
### 消息中心JDBC链接：链接地址请保持和 2.1章节 所创建的数据库的地址一致
spring.datasource.url=jdbc:mysql://127.0.0.1:3306/xxl_mq?useUnicode=true&characterEncoding=UTF-8&autoReconnect=true&serverTimezone=Asia/Shanghai
... 

### 报警邮箱
spring.mail.host=smtp.qq.com
spring.mail.port=25
spring.mail.username=xxx@qq.com
spring.mail.password=xxx
... 

### 消息中心国际化配置 [必填]： 默认为 "zh_CN"/中文简体, 可选范围为 "zh_CN"/中文简体, "zh_TC"/中文繁体 and "en"/英文；
xxl.mq.i18n=zh_CN
``` 

#### 步骤二：消息中心部署：  
如果已经正确进行上述配置，可将项目编译打包部署。

消息中心访问地址：http://127.0.0.1:8080/xxl-mq-admin  (该地址接入方项目将会使用到)。

默认登录账号 "admin/123456", 登录后运行界面如下图所示。

![输入图片说明](https://www.xuxueli.com/doc/static/xxl-mq/images/img_01.png "在这里输入图片标题")

至此“消息中心”项目已经部署成功。

#### 步骤三：消息中心集群（可选）：
消息中心支持集群部署，提升消息系统容灾和可用性。

消息中心集群部署时，几点要求和建议：
- DB配置保持一致；
- 集群机器时钟保持一致（单机集群忽视）；
- 建议：推荐通过nginx为消息中心集群做负载均衡，分配域名。消息中心访问、客户端使用等操作均通过该域名进行。

#### 其他：Docker 镜像方式搭建消息中心：
- 下载镜像

```
// Docker地址：https://hub.docker.com/r/xuxueli/xxl-mq-admin/
docker pull xuxueli/xxl-mq-admin
```

- 创建容器并运行

```
/**
* 如需自定义 mysql 等配置，可通过 "-e PARAMS" 指定，参数格式 PARAMS="--key=value  --key2=value2" ；
* 配置项参考文件：/xxl-mq/xxl-mq-admin/src/main/resources/application.properties
* 如需自定义 JVM内存参数 等配置，可通过 "-e JAVA_OPTS" 指定，参数格式 JAVA_OPTS="-Xmx512m" ；
*/
docker run -e PARAMS="--spring.datasource.url=jdbc:mysql://127.0.0.1:3306/xxl_mq?useUnicode=true&characterEncoding=UTF-8&autoReconnect=true&serverTimezone=Asia/Shanghai" -p 8080:8080 -v /tmp:/data/applogs --name xxl-mq-admin  -d xuxueli/xxl-mq-admin:{指定版本}
```


### 2.4 接入XXL-MQ并使用

    接入XXL-MQ项目："xxl-mq-samples-springboot" (提供多种版本示例项目供参考选择，现以springboot版本为例讲解)
    作用：生产消息、消费消息；可直接部署，也可以将集成到现有业务项目中。

#### 步骤一：maven依赖
确认pom文件中引入了 "xxl-mq-core" 的maven依赖；

#### 步骤二："消息接入方" 项目配置
消息接入方配置，配置文件地址：

```
/xxl-mq/xxl-mq-samples/xxl-mq-samples-springboot/src/main/resources/application.properties
```

消息接入方配置，配置内容说明：

```
# 消息中心根地址 [必填]；支持配置多个，建议域名方式配置；
xxl.mq.admin.address=http://127.0.0.1:8080/xxl-mq-admin
# 通讯TOKEN [必填]：非空时启用；
xxl.mq.admin.accesstoken=defaultaccesstoken
# 客户端AppName [必填]：与消息主题/Topic自动绑定；
xxl.mq.client.appname=xxl-mq-sample
# 客户端通讯超时时间[选填]，单位秒；默认3s；
xxl.mq.client.timeout=3000
# 客户端消费者启用开关[选填]，默认true/启用；如果关闭，则客户端将不再拉取消息消费；
xxl.mq.client.consumer.enabled=true
# 客户端批量拉消息批次大小[选填]，默认100；合法区间 [20, 500]
xxl.mq.client.consumer.pull.batchsize=100
# 客户端拉消息批次间隔时间[选填]，单位毫秒；默认3000ms；合法区间 [1000, 30000]
xxl.mq.client.consumer.pull.interval=1000
```
    
#### 步骤三："消息接入方" 组件配置

```
@Bean
public XxlMqSpringBootstrap getXxlMqConsumer(){
    // init xxl-mq spring bootstrap
    XxlMqSpringBootstrap xxlMqBootstrap = new XxlMqSpringBootstrap();
    xxlMqBootstrap.setAddress(address);
    xxlMqBootstrap.setAccesstoken(accesstoken);
    xxlMqBootstrap.setAppname(appname);
    xxlMqBootstrap.setTimeout(timeout);
    xxlMqBootstrap.setPullBatchsize(batchsize);
    xxlMqBootstrap.setPullInterval(interval);

    return xxlMqBootstrap;
}
```    
    
#### 步骤四："消息接入方" 部署

如果已经正确进行上述配置，可将"消息接入方"项目编译打部署，系统提供多种Sample示例项目，选择其中一个即可，各自的部署方式如下。

    xxl-mq-samples-springboot：项目编译打包成springboot类型的可执行JAR包，命令启动即可；
    xxl-mq-samples-frameless：项目编译打包成JAR包，命令启动即可；

至此“消息接入方”项目已经部署结束。

如果已经正确进行上述配置，可将项目编译打包部署。
springboot版本示例项目，访问地址：http://127.0.0.1:8081/


#### 步骤五："消息接入方" 集群（可选）：
消息接入方支持集群部署，提升消息系统可用性，同时提升消息处理能力。

消息接入方集群部署时，要求和建议：
- 消息中心根地址（xxl.mq.admin.address）需要保持一致；
- 同一个客户端集群内AppName（xxl.mq.client.appname）需要保持一致；消息中心消息路由时根据Topic匹配关联的AppName，并发现AppName在线消费节点列表。


### 2.5 生产消息、消费消息

#### a、生产消息

**消息生产API说明：**

API：com.xxl.mq.core.XxlMqHelper.produce
参数：
  - topic：消息主题
  - data：消息数据
  - effectTime：消息延迟生效时间，为空时立即执行；
  - bizId：业务参数ID，支持根据业务参数进行Hash分片，相同分片的消息数据路由至同一个消费者FIFO串行消费，不同分片的消息数据路由至不同消费者并行执行。

**消息生产示例代码**
```
/**
 * 1、并行消息：
 * 		实现方式：消息中心，Topic属性 “分区策略” 选择为 “轮询” 或 “随机”
 * 		测试Topic：	topic_sample
 */
XxlMqHelper.produce("topic_sample", "并行消费");


/**
 * 2、串行消息：
 * 		实现方式：消息中心，Topic属性 “分区策略” 选择为 “第一个” 或 “最后一个”
 * 		测试Topic：topic_sample_02
 */
XxlMqHelper.produce("topic_sample_02", "串行消费");


/**
 * 3、分片消息：
 * 		实现方式：
 * 			a、消息中心：Topic 路由策略 = “Hash”；
 * 			b、客户端：生产消息时，自定义消息 “BizId”（作为 “分区hash“ 的 ”业务参数“ ）。相同 BizId 的消息将会被Hash到同一个分区，由同一个消费者串行消费执行；不同 BizId 的消息数据，将会在多个分区并行执行；
 * 		测试Topic：	topic_sample_03
 */
long bizId = 1000;
XxlMqHelper.produce("topic_sample_03", "分片消息", -1, bizId);


/**
 * 4、广播消费：
 * 		实现方式：消息中心，Topic属性 “分区策略” 选择为 “广播”
 * 		测试Topic：	topic_sample_04
 */
XxlMqHelper.produce("topic_sample_04", "广播消费");	


/**
 * 5、延时消息（模拟 延时3min）：
 * 		实现方式：客户端，消息生产时自定义设置 “effectTime”，消息将在指定时间触发消费；
 * 		测试Topic：	topic_sample_05
 */
Calendar calendar = Calendar.getInstance();
calendar.add(Calendar.MINUTE, 3);
Date effectTime = calendar.getTime();

XxlMqHelper.produce("topic_sample_05", "延时消息（模拟 延时3min）",  effectTime.getTime());

/**
 * 6、失败重试消息（模拟 重试3次）：
 * 		实现方式：消息中心，Topic属性 “重试次数” 设置大于零，并设置 “重试策略”、“重试间隔” 即可。
 * 		测试Topic：	topic_sample_06
 */
XxlMqHelper.produce("topic_sample_06", "失败重试消息（模拟 重试3次））");
```

#### b、消费消息 

**消费者注解说明：**

注解：com.xxl.mq.core.consumer.annotation.XxlMq
参数：
- value：消息主题
- init：消费者初始化方法，可选；消息初始化时执行一次；
- destroy：消费者销毁方法，可选；消息销毁时执行一次；

**消费者示例代码**

```
@XxlMq("topic_sample")
public void consume() {

    // 获取消息ID，可用于消息幂等；
    long messageId = XxlMqHelper.getMessageId();
    
    // 获取消息内容；
    String messageData = XxlMqHelper.getMessageData();

    // 设置消息消费结果，可选；不设置时，默认为消费成功；
    XxlMqHelper.consumeSuccess();
}
```


### 2.6 功能测试 & 性能测试

依次启动 “消息中心”、 "springboot版本示例项目"、"frameless版本示例项目"，访问地址如下：
- 消息中心：http://127.0.0.1:8080/xxl-mq-admin
- "springboot版本示例项目"：http://127.0.0.1:8081/

访问部署成功的 "springboot版本示例项目" 地址，浏览器访问展示如下如下：

![输入图片说明](https://www.xuxueli.com/doc/static/xxl-mq/images/img_02.png "在这里输入图片标题")

该示例项目已经提供了多个消息生产与消费的实例：

#### a、"并行消息" 测试：   
连续点击 "并行消费" 按钮3次，将会生产3条并行消息；

进入消息中心 "消息管理" 菜单，输入指定“topic = topic_sample” 查询，消息数据如下：
![输入图片说明](https://www.xuxueli.com/doc/static/xxl-mq/images/img_06.png "在这里输入图片标题")

并行消费逻辑说明：
- 分区范围：进入“服务管理”菜单，可以看到消费者服务（xxl-mq-sample）注册节点数为2。消息中心固定总分区数 1W，因此2个客户端各自负责分区范围为 [1, 5000]、[5001, 10000]。
- 并行逻辑：进入“主题管理”才看，可以看到 “topic = topic_sample” 的 “分区策略” 选择为 “轮询”；消息分区路由将会依次分配给2个注册节点，因此 partitionId（分区ID）依次为 “1、5001、1”，符合预期。 

点击 “查看消费轨迹”按钮，支持查看消息轨迹日志，包括生产、路由、消费详细日志：
![输入图片说明](https://www.xuxueli.com/doc/static/xxl-mq/images/img_04.png "在这里输入图片标题")


#### b、"串行消息" 测试：   
连续点击 "触发生产" 按钮3次，将会生产3条串行消费；

进入消息中心 "消息管理" 菜单，输入指定“topic = topic_sample_02” 查询。可见 partitionId 固定为 1 ，将会固定分配给一个消费者。符合预期。

#### c、"分片消息"：  
连续点击 "触发生产" 按钮3次，将会生产3条分片消息；

进入消息中心 "消息管理" 菜单，输入指定“topic = topic_sample_03” 查询。底层根据 业务参数/BizId 进行分区Hash ，相同 BizId 将会固定分配给一个消费者。符合预期。

#### d、"广播消费"：  
点击 "触发生产" 按钮，将会生产一条广播消息；

进入消息中心 "消息管理" 菜单，输入指定“topic = topic_sample_04” 查询。一条广播请求将会广播给2个在线消费者，生成2条广播消息记录，符合预期。

#### e、"延时消息"：  
点击 “触发生产” 按钮，将会生产一条延时消息；

进入消息中心 "消息管理" 菜单，输入指定“topic = topic_sample_05” 查询。由于设置延时 3min，最终消息在 3min 之后被消费执行。符合预期。

#### f、"失败重试消息"：    
点击 “触发生产” 按钮一次，将会生产一条失败重试消息；

进入消息中心 "消息管理" 菜单，输入指定“topic = topic_sample_06” 查询。由于设置失败重试 3次（测试逻辑，固定设置消费失败），消息在将被重试3次。符合预期。

#### g、"性能测试" 测试：   
点击 “触发生产” 按钮一次，将会批量发送10000条消息；

点击按钮后，页面下方展示文案 “Send message count : 10000, Cost : 16 ms”，说明在 16ms 之内客户端发送了 10000 条消息；
但是，由于测试代码中采用异步方式发送，消息发送事件与是否成功需要在消息中心中确认。

进入消息中心 "消息管理" 菜单，输入指定“topic = topic_sample_07” 查询。点击所生产消息的 “查看消费轨迹”，可见最大和最小生产时间相差1S，说明 1S 内客户端生产了 1W条消息、且 100% 投递成功，即单机TPS过万；

![输入图片说明](https://www.xuxueli.com/doc/static/xxl-mq/images/img_14.png "在这里输入图片标题")

#### 其他测试
如延时消息、重试消息 …… 可自行参考示例代码测试；


## 三、消息中心 操作指南

### 3.1 运行报表：
首页的运行报表界面，展示消费者服务、消息主题、消息数量等；支持以日期分布图、成功比例图方式查看消息生产消费情况。（注意：报表存在10min延迟）

![输入图片说明](https://www.xuxueli.com/doc/static/xxl-mq/images/img_01.png "在这里输入图片标题")

### 3.2 消息主题
消息主题界面，可查看在线消息主题列表；
![输入图片说明](https://www.xuxueli.com/doc/static/xxl-mq/images/img_08.png "在这里输入图片标题")

消息主题管理：支持在线管理 “消费主题”，维护消息主题属性：（详细属性，可查看章节 “ 4.2.1、消息主题（Topic）” ）
![输入图片说明](https://www.xuxueli.com/doc/static/xxl-mq/images/img_11.png "在这里输入图片标题")

### 3.3 消息管理
消息管理界面，支持 "新增"、"编辑" 和 "删除" 实时消息数据，支持查看“消息消费轨迹”；
![输入图片说明](https://www.xuxueli.com/doc/static/xxl-mq/images/img_06.png "在这里输入图片标题")

消息属性编辑：如下图所示，可修改消息属性：
![输入图片说明](https://www.xuxueli.com/doc/static/xxl-mq/images/img_12.png "在这里输入图片标题")

消息归档/清理：支持在线归档、清理消息，可选择消息主题、归档策略*等；  
![输入图片说明](https://www.xuxueli.com/doc/static/xxl-mq/images/img_13.png "在这里输入图片标题")

### 3.4 消费者服务管理
消费者服务管理界面，可查看服务列表：
![输入图片说明](https://www.xuxueli.com/doc/static/xxl-mq/images/img_10.png "在这里输入图片标题")

点击 “查看注册节点”，可查看消费者服务在线节点，以及 “注册节点/UUID” 与 “责任分区范围”（用于消息分区路由）。
![输入图片说明](https://www.xuxueli.com/doc/static/xxl-mq/images/img_15.png "在这里输入图片标题")


## 四、总体设计

### 4.1、架构设计
#### 4.1.1、设计思想

XXL-MQ整体基于 “存算分离” 与 “分区机制” 的设计思想：
- **存算分离**：消息中心（Broker）与消息存储层（Store）解耦。消息中心 提供消息OpenApi以及消息控制台管理能力；消息存储层 提供消息存储能力。得益于存算分离系统设计，消息中心支持水平扩展，支持线性提升消息吞吐及存储能力。
- **分区机制**：针对消息数据进行分区路由计算及隔离，结合在线消费者进行 “分区动态平衡分配”（每个消费者分配负责分区区间），实现消费者与消息数据的灵活路由绑定。基于分区机制，灵活实现并行、串行、分片、Hash、广播...等多消息类型，保障系统高吞吐特性。

#### 4.1.2、系统组成

- **a、Broker模块（消息中心）**：
    承担消息生产及消费代理、消息元数据控制台管控等职责。面向消息Producer，接收所生产消息数据、并进行分片路由计算及存储；面向消息Consumer，提供节点注册及分区平衡分配，以及消息拉取及结果回调能力。
    同时，提供消息中心控制台，支持通过线上化页面针对 消息主题、消息数据、消费者服务 等进行管理。

- **b、Client模块（客户端）**：    
    消息客户端，核心由 消息生产者、消息消费者 组成。消息生产者，提供消息数据生产能力，消息将会投递消息中心持久化存储；消息消费者，支持消息订阅及消费能力，实现多消息类型。

#### 4.1.3、架构图

![输入图片说明](https://www.xuxueli.com/doc/static/xxl-mq/images/img_03.png "在这里输入图片标题")

### 4.2、消息核心模型

XXL-MQ 核心模型包括：
- Topic：消息主题, 每个消息队列的唯一性标示;
- Partition（Topic）: 消息分区，每个Topic固定分配1W个分区。消息生产时，结合路由策略针对消息数据进行分区绑定；消息消费时，针对在线消费者前置进行“分区动态平衡分配”（每个消费者分配负责分区区间），最终借助分区实现消息与消费者路由绑定。
- Message：消息实体，关联 Topic 及 Partition。 
- Producer : 消息生产者, 绑定指定消息Topic, 并向该Topic消息队列中生产消息;
- Consumer : 消息消费者, 绑定指定消息Topic, 定位相关Topic消息并消费。

#### 4.2.1、消息主题（Topic）

“消息主题（Topic）”属性说明：
```
- 基础配置：
    - Topic：消息主题
    - AppName：消费者服务标识，用于消费者节点注册发现；
    - 主题描述：消息主题描述信息；
    - 负责人：Topic负责人；
    - 告警配置：消息消费失败告警信息接收邮箱，多个逗号分隔；
  - 存储路由：
      - 分区路由：
          - Hash：根据 业务参数/BizId 进行分区Hash，相同 BizId 将会固定分配给一个消费者。partitionId 设置为相关消费者负责的分区ID。
          - 轮询：按照在线的消费者服务节点，轮询路由匹配消费者节点。
          - 随机：按照在线的消费者服务节点，随机路由匹配消费者节点。
          - 第一个：固定选择第一个消费者，partitionId 设置为其负责的分区ID。
          - 最后一个：固定选择第一个消费者，partitionId 设置为其负责的分区ID。
          - 广播：消息发送后，广播发送给相关主题全部在线消费者。
      - 归档策略：
          - 归档保留7天：针对 7天内 消费完成的消息数据进行归档，从“实时消息表”转移到“归档消息表”进行保留，更早的历史消息清理。
          - 归档保留30天：针对 30天内 消费完成的消息数据进行归档，从“实时消息表”转移到“归档消息表”进行保留，更早的历史消息清理。
          - 归档保留90天：针对 90天内 消费完成的消息数据进行归档，从“实时消息表”转移到“归档消息表”进行保留，更早的历史消息清理。
          - 归档永久保留：全部消费完成的消息数据进行归档，从“实时消息表”转移到“归档消息表”，永久保留不清理。
          - 不归档直接清理：全部消费完成的消息数据，直接清理不保留。
  - 消费策略
      - 重试策略：
          - 固定间隔重试：消息消费失败后，固定延迟 “重试间隔” 设置的时间后重试执行，重试次数为 “重试次数” 设置的值。
          - 线形间隔重试：消息消费失败后，以 “重试间隔” 设置的间隔时间为基础递增，依次延时 "一倍间隔、两倍间隔、三倍间隔 ... " 时间后重试执行。
          - 随机间隔重试：消息消费失败后，在 0 到 “重试间隔” 范围内获取随机值，随机延迟一定时间后重试执行。
      - 重试次数：消息消费失败后，允许重试的次数；大于0时生效；
      - 重试间隔：消息失败后，距离下次重试执行的间隔时间；注意，最终重试间隔时间需要结合 “重试策略” 最终确定；
      - 超时时间：支持自定义消费超时时间，消费运行超时将会主动中断；
```

#### 4.2.2、消息数据（Message）

| 消息核心属性          | 说明                             |
|-----------------|--------------------------------|
| Topic           | 消息主题                           |
| PartitionId     | 消息分区ID，用于结合分区路由策略，关联匹配消费者      |
| 生效时间            | 消息延迟生效时间，非空时到达该时间后才执行，为空时立即执行； |
| 消息数据            | 消息数据                           |
| 消息状态            | 消息运行状态                         |


### 4.3、消息中心 设计
#### 4.3.1、Broker 服务    
消息中心，承担消息生产及消费代理、消息元数据控制台管控等职责。面向消息Producer，接收所生产消息数据、并进行分片路由计算及存储；面向消息Consumer，提供节点注册及分区平衡分配，以及消息拉取及结果回调能力。
同时，提供消息中心控制台，支持通过线上化页面针对 消息主题、消息数据、消费者服务 等进行管理。

#### 4.3.2、海量数据堆积       
消息中心数据存储（Store），原生兼容支持 "MySQL、TIDB" 两种存储方式，前者支持千万级消息堆积，后者支持百亿级别消息堆积（TIDB理论上无上限）；

可视情况选择使用，当选择TIDB时，仅需要修改消息中心数据库连接jdbc地址配置即可，其他部分如SQL和驱动兼容MySQL和TIDB使用，不需修改。

### 4.4、客户端 设计
#### 4.4.1、Producer 设计      

消息生产全流程 “批量化、异步化” 处理，从而实现系统高吞吐。整体流程步骤为：
- a、客户端生产：底层针对消息格式进行基础校验，校验通过消息写入本地Queue；
- b、客户端消息投递：客户端异步线程处理消息投递工作，将批量读取queue中新消息数据，并基于JsonRpc与消息中心OpenAPI进行批量消息投递；
- c、消息中心消息接收：消息中心接受生产者投递消息后，写入本地queue；
- d、消息中心消息处理、存储：消息中心异步线程，批量读取queue中新消息数据，结合消息Topic的分区路由策略计算分区ID，并完成消息持久化存储。

#### 4.4.2、Consumer 设计

消息消费者，通过 “分区动态平衡分配 + 统一Pull轮询 + 消费者路由 + 消息延时队列 + 消费结果回调”，实现灵活消息分区路由、以及秒级别延时消息执行等。整体流程步骤为：
- a、消费者注册：消费者节点注册到消息中心，完成 “分区动态平衡分配”（每个消费者分配负责分区区间）
- b、统一Pull轮询：消费者节点轮询消息中心，根据消息中心分配的责任分区区间，拉取消息数据。
- c、消费者路由：针对拉取的消息进行客户端路由，匹配并数据推动给相关消费者。
- d、消息延时队列：消费者组件接受数据消息，结合消息生效时间决策立即，或推动延迟队列。
- e、消费结果回调：消费者消费完成后，回调消费结果给消息中心。流程同上文消息生产，略。


### 4.5、消息类型设计

当前支持多种 消息类型，灵活支持不同业务场景：
- **并行消息**：多个消费者并行消费数据，支持轮询或随机策略。适用于消息吞吐量较大的业务场景，如邮件发送、日志记录等。
- **串行消息**：同一时刻只有一个消费者消费数据，消息按照生产顺序FIFO串行消费。适用于有串行消费诉求的业务场景，如秒杀、抢单等场景；
- **分片消息**：支持根据业务参数进行Hash分片，相同分片的消息数据路由至同一个消费者FIFO串行消费，不同分片的消息数据路由至不同消费者并行执行。适用于有根据业务参数分片消费的业务场景，如短信发送，可实现同一个手机号（业务参数）的消息路由至单个消费者串行消息，同时全局消息分片并行消费。
- **广播消息**：消息发送后，广播发送给相关主题全部在线消费者。适用于广播消息场景，如广播通知、广播更新缓存等；
- **延时消息**：支持设置消息的延迟生效时间，到达设置的生效时间时该消息才会被消费。适用于延时消费场景，如订单超时取消、定时发送邮件等；
- **失败重试消息**：支持设置消息的失败重试次数，自定义重试间隔侧路，消息失败时会主动进行重试消费，直至重试次数耗尽或者消费成功。

### 4.6 超时控制
支持自定义消息超时时间，消息消费超时将会主动中断；


## 五、消息中心 OpenApi

XXL-MQ 提供语言无关的消息中心 OpenAPI（RESTFUL 格式），提供消息生产、拉取及消费等能力，实现多语言支持；
- 针对Java应用，可以直接通过官方提供的SDK快捷的接入消息中心，进行消息生产及消费，可以参考上文 “快速入门” 章节。
- 针对非Java应用，可借助 XXL-MQ 的标准 OpenApi（RESTful API） 方便的实现多语言支持。

API服务位置：com.xxl.mq.admin.broker.openapi.OpenApiController
API服务请求参考代码：com.xxl.mq.core.test.openapi.OpenApiClientTest

#### a、客户端（消费端）注册
```
说明：客户端（消费端）注册时使用，消息中心会实时感知注册成功的消费者进行分区分配及消息路由；

------
请求数据JSON格式，放置在 RequestBody：
    {
      "service": "brokerService",
      "method": "registryRemove",
      "params": [
        {
          "accesstoken": "{消息中心通讯TOKEN}",
          "appname": "{消费者服务appkey}",
          "instanceUuid": "{消费者服务实例UUID，可自定义，但需保持唯一}",
          "topicList": [
            "{消息主题Topic",
            "{消息主题Topic}"
          ]
        }
      ]
    }

响应数据JSON格式：
    {
        "error":"",                             // 系统异常信息，默认为空；非空时表示发生系统异常；
        "data":{
            "code":200,                         // 业务状态码；200 表示正常、其他失败；
            "msg":""                            // 业务错误提示消息；
        }
    }
```

#### b、客户端（消费端）注册摘除
```
说明：客户端（消费端）注册摘除时使用，消息中心会实时感知注册成功的消费者进行分区分配及消息路由；

------
地址格式：{消息中心根地址}/openapi

请求数据JSON格式，放置在 RequestBody：
    {
      "service": "brokerService",
      "method": "registryRemove",
      "params": [
        {
          "accesstoken": "{消息中心通讯TOKEN}",
          "appname": "{消费者服务appkey}",
          "instanceUuid": "{消费者服务实例UUID，可自定义，但需保持唯一}",
          "topicList": [
            "{消息主题Topic}",
            "{消息主题Topic}"
          ]
        }
      ]
    }

响应数据JSON格式：
    {
        "error":"",                             // 系统异常信息，默认为空；非空时表示发生系统异常；
        "data":{
            "code":200,                         // 业务状态码；200 表示正常、其他失败；
            "msg":""                            // 业务错误提示消息；
        }
    }
```

#### c、生产消息
```
说明：生产消息时使用，支持批量消息生产；

------
地址格式：{消息中心根地址}/openapi

请求数据JSON格式，放置在 RequestBody：
    {
      "service": "brokerService",
      "method": "produce",
      "params": [
        {
          "accesstoken": "{消息中心通讯TOKEN}",
          "messageList": [
            {
              "topic": "{消息主题Topic}",
              "data": "{消息数据}",
              "bizId": {业务参数ID，选填；仅Topic路由策略为“Hash”时生效，用于分区路由},
              "effectTime": {消息生效时间，选填，为空时表示立即生效；格式为时间戳/毫秒}
            },
            {
              "topic": "{消息主题Topic}",
              "data": "{消息数据}",
              "bizId": {业务参数ID，选填；仅Topic路由策略为“Hash”时生效，用于分区路由},
              "effectTime":  {消息生效时间，选填，为空时表示立即生效；格式为时间戳/毫秒}
            }
          ]
        }
      ]
    }

响应数据JSON格式：
    {
        "error":"",                             // 系统异常信息，默认为空；非空时表示发生系统异常；
        "data":{
            "code":200,                         // 业务状态码；200 表示正常、其他失败；
            "msg":""                            // 业务错误提示消息；
        }
    }
```

#### d、消费消息
```
说明：消费消息时使用，支持批量回调消息消费结果；

------
地址格式：{消息中心根地址}/openapi

请求数据JSON格式，放置在 RequestBody：
    {
      "service": "brokerService",
      "method": "consume",
      "params": [
        {
          "accesstoken": "{消息中心通讯TOKEN}",
          "messageList": [
            {
              "id": {消息ID},
              "topic": "{消息主题Topic}",
              "status": {消息状态：0-初始状态，1-消费中，2-消费成功，3-消费失败，4-消费超时},
              "consumeLog": "{消息消费日志，用于问题追溯，可选}",
              "consumeInstanceUuid": "{消费者服务实例UUID，可自定义，但需保持唯一}",
            },
            {
              "id": {消息ID},
              "topic": "{消息主题Topic}",
              "status": {消息状态：0-初始状态，1-消费中，2-消费成功，3-消费失败，4-消费超时},
              "consumeLog": "{消息消费日志，用于问题追溯，可选}",
              "consumeInstanceUuid": "{消费者服务实例UUID，可自定义，但需保持唯一}"
            }
          ]
        }
      ]
    }

响应数据JSON格式：
    {
        "error":"",                             // 系统异常信息，默认为空；非空时表示发生系统异常；
        "data":{
            "code":200,                         // 业务状态码；200 表示正常、其他失败；
            "msg":""                            // 业务错误提示消息；
        }
    }
```

#### e、Pull消息前置校验
```
说明：Pull消息前置校验，包括分区、实例ID、消费者appkey等合法校验；

------
地址格式：{消息中心根地址}/openapi

请求数据JSON格式，放置在 RequestBody：
    {
      "service": "brokerService",
      "method": "pullPreCheck",
      "params": [
        {
          "accesstoken": "{消息中心通讯TOKEN}",
          "appname": "{消费者服务appkey}",
          "instanceUuid": "{消费者服务实例UUID，可自定义，但需保持唯一}",
          "topicList": [
            "{消息主题Topic}",
            "{消息主题Topic}"
          ],
          "batchsize": {批量拉取消息数量}
        }
      ]
    }

响应数据JSON格式：
    {
        "error":"",                             // 系统异常信息，默认为空；非空时表示发生系统异常；
        "data":{
            "code":200,                         // 业务状态码；200 表示正常、其他失败；
            "msg":""                            // 业务错误提示消息；
        }
    }
```

#### f、Pull消息数据
```
说明：Pull消息数据，同时会将Pull成功消息改为“消费中”状态避免重复拉取；

------
地址格式：{消息中心根地址}/openapi

请求数据JSON格式，放置在 RequestBody：
    {
      "service": "brokerService",
      "method": "pullAndLock",
      "params": [
        {
          "accesstoken": "{消息中心通讯TOKEN}",
          "appname": "{消费者服务appkey}",
          "instanceUuid": "{消费者服务实例UUID，可自定义，但需保持唯一}",
          "topicList": [
            "{消息主题Topic}",
            "{消息主题Topic}"
          ],
          "batchsize": {批量拉取消息数量}
        }
      ]
    }

响应数据JSON格式：
    {
        "error":"",                             // 系统异常信息，默认为空；非空时表示发生系统异常；
        "data":{
            "code":200,                         // 业务状态码；200 表示正常、其他失败；
            "msg":"",                            // 业务错误提示消息；
            "data":[
                {
                  "id": {消息ID},
                  "topic": "{消息主题Topic}",
                  "data": "{消息数据}",
                  "effectTime":  {消息生效时间，格式为时间戳/毫秒}
                }
            ]
        }
    }
```


## 六、版本更新日志
### v1.1.0 新特性
- 1、简单易用: 一行代码即可发布一条消息; 一行注解即可订阅一个消息主题;
- 2、部署简单: 除ZK之外不依赖第三方服务;
- 3、三种消息模式: TOPIC(广播消息)模型、QUEUE(并发队列)模型 和 SERIAL_QUEUE(串行队列)模型,下文将会详细讲解:
- 4、Broker集群、HA: Broker支持集群部署, 可大大提高系统可用性,以及消息吞吐能力;
- 5、吞吐量: 依赖于部署的Broker集群和Mysql性能;
- 5、消息可追踪: 支持追踪每一条消息的执行路径, 便于排查业务问题;
- 6、消息可见: 系统中每一条消息可通过Web界面在线查看,甚至支持编辑消息内容和消息状态;
- 7、一致性: QUEUE(并发队列)模型 和 SERIAL_QUEUE(串行队列)模型的消息,保证只会成功执行一次;
- 8、Delay执行: 支持设置消息的延迟生效时间, 到达设置的Delay执行时间时该消息才会被消费 ,提供DelayQueue的功能;
- 9、消息重试: 支持设置消息的重试次数, 在消息执行失败后将会按照设置的值进行消息重试执行,直至重试次数耗尽或者执行成功;

### v1.1.1 特性
- 1、项目groupId改为com.xuxueli，为推送maven中央仓库做准备；
- 2、项目推送Maven中央仓库；
- 3、底层系统优化，CleanCode等；
- 4、修复confirm和alert弹框冲突导致消息列表错乱的问题；
- 5、优化ZK注册逻辑,ZK注册基础路径提前初始化；
- 6、broadcast 广播消息时ZK 发送方不进行watch, 否则发送方也会监听到；
- 7、修复一处因ReentrantLock导致可能死锁的问题；

### v1.2.0 Release Notes[2018-11-28]
- 1、client端与Broker长链初始化优化，防止重复创建连接。
- 2、POM多项依赖升级；
- 3、UI组件升级；
- 4、规范项目目录结构；
- 6、超时控制；
- 5、通讯迁移至 xxl-rpc；
- 6、除了springboot类型示例；新增无框架示例项目 "xxl-mq-samples-frameless"。不依赖第三方框架，只需main方法即可启动运行；
- 7、消息生产，兼容“异步批量多线程生产”+“同步生产”两种方式，提升消息发送性能；
- 8、底层通讯全异步化：消息新增 + 消息新增接受 + 消息回调 + 消息回调接受；仅批量PULL消息与锁消息非异步；
- 9、串行消费优化，旧版本固定第一台消费，导致其压力过大；新版支持自定义shardingId从而实现串行消息的负载均衡，缓解单台压力；
- 10、广播消息优化，旧版本不支持消息持久化，新版本支持消息持久化，而且广播支持与串行结合实用，更加灵活；
- 11、并发消息、串行消息、广播消息全部优化重构，底层逻辑统一，方便后续维护扩展；
    - 串行：取消ZK依赖，废弃旧版ZK锁方式；优化为通过消息 shardingId 结合消费者排序取模方式；相同 shardingId 的消息将会固定被同一个消费者消费；
    - 并行：沿用旧版消费者排序取模方式，不过取模参数新增支持 shardingId 参数；确保消息平均分配给在线消费者；
    - 广播：取消ZK依赖，废弃旧版ZK方式；优化为通过消息 group 属性群发方式；每个group都会消费该消息，但相同group下消息仅被消费一次；
- 12、Broker服务支持自定义指定注册IP等信息，位置 "XxlMqBrokerImpl.initServer"；
- 13、Topic自动发现：消息中心支持动态发现Topic，并展示在消息主题列表，延时1min；
- 14、运行报表：支持展示在线业务线、消息主题、消息记录等信息、可在线查看消息日期分布图，成功分布图等；
- 15、业务线管理：支持设置业务线，用于分组管理消息主题；
- 16、消息主题管理：支持在线管理消息主题，自动发现消息主题；并支持完善消息主题扩展信息，如业务线、负责人、告警邮箱等；
- 17、消息记录界面，交互优化重构，进一步优化消息筛选、管理交互；
- 18、自动重试优化，任务重试时，生效时间重置为1min之后，重试次数减一；
- 19、记住密码功能优化，选中时永久记住；非选中时关闭浏览器即登出；
- 20、事务开关：支持设置消息事务开关，开启时事务保证消息精准消费一次；未开启时小概率存在重复消费，仅依靠注册中心分片检测避免重复，但性能略高；
- 21、告警功能：支持以Topic粒度监控消息，存在失败消息时主动推送告警邮件；
- 22、轨迹Log优化，新增、更新时记录核心数据；消息日志格式统一；
- 23、消息在线清理：在消息记录界面，支持在线清理消息数据；
- 24、过期消息自动清理：消息中心新增参数 “xxl-mq.log.logretentiondays”设置消息过期天数，过期成功消息将会自动清理；
- 25、超时强化，除了客户端支持超时控制外；服务端新增线程扫描，主动处理超时消息；消息超过 "生效时间 + 超时时间 + 1HOUT" 之后仍然未结束，将会主动标记为失败；
- 26、左侧菜单规范：运行报表（业务线，主题数，消息记录数；总消息成功率，日分布柱状图，总分布饼图） + 消息主题 + 消息记录 + 使用教程；
- 27、注册中心迁移至DB，基于 "long polling" 实现注册机器实时感知；注册中心代码及逻辑来源自“XXL-RPC原生轻量级注册中心”；
- 28、轻量级改造，移除对ZK依赖，仅依赖DB即可完整集群方式提供服务；缺点，非强一致性可能导致重复消费，开启事务开关可以避免该问题；
- 29、文档示例完善，包括：并发消息、串行消息、广播消息、延迟消息、失败重试消息、超时控制消息等；
- 30、文档完善：消息模型说明，延时消息说明、事务消息说明、失败重试、超时控制说明，


### v1.2.1 Release Notes[2018-12-02]
- 1、单机TPS过万：示例项目中新增功能测试、性能测试用例，以及消息生产、消费、成功率等方便的数据分析；可参考示例项目性能测试用例（章节 “2.6 功能测试 & 性能测试”），单机TPS过万；
- 2、底层long polling监控keys非法去重问题修复；
- 3、注册逻辑优化，批量注册，提高注册性能，降低注册中心压力；
- 4、消息中心RPC服务支持自定义注册IP地址；
- 5、消息中心内置注册中心线程数优化，精简；

### v1.2.2 Release Notes[2018-12-21]
- 1、访问令牌（accessToken）：为提升系统安全性，消息中心和客户端进行安全性校验，双方AccessToken匹配才允许通讯；
- 2、支持批量注册、摘除，提升注册发现性能；升级 xxl-rpc 至 v1.3.1;
- 3、升级 pom 依赖至较新版本；
- 4、表结构调整提升兼容性，表名转小写；
- 5、客户端取消Consumer非空的限制；

### v1.3.0 Release Notes[2025-02-07]
- 1、【增强】消费者分组属性 "group" 支持为空，为空时自动赋值UUID，方便实现多分组广播消费；
- 2、【增强】海量数据堆积：消息数据存储在DB中，原生兼容支持 "MySQL、TIDB" 两种存储方式，前者支持千万级消息堆积，后者支持百亿级别消息堆积（TIDB理论上无上限）；
- 3、【优化】消费者批量注册发现，提高注册发现性能；
- 4、【优化】消息流转日志格式优化，提升日志可读性；
- 5、【优化】升级xxl-rpc、xxl-registry至较新版本，Broker注册发现服务做适配性优化；

### v1.4.0 Release Notes[2025-05-24]
- 1、【重构】XXL-MQ 核心代码重构，基于“存算分离”与“分区机制”设计思想。在轻量级、分布式的基础上，强化高吞吐、海量消息及水平扩展能力。；
- 2、【新增】存算分离：消息中心（Broker）与消息存储层（Store）解耦。消息中心 提供消息OpenApi以及消息控制台管理能力；消息存储层 提供消息存储能力。得益于存算分离系统设计，消息中心支持水平扩展，支持线性提升消息吞吐及存储能力。
- 3、【新增】分区机制：针对消息数据进行分区路由计算及隔离，结合在线消费者进行 “分区动态平衡分配”（每个消费者分配负责分区区间），实现消费者与消息数据的灵活路由绑定。基于分区机制，灵活实现并行、串行、分片、Hash、广播...等多消息类型，保障系统高吞吐特性。
- 4、【增强】扩展支持多消息类型:
  - 并行消息：多个消费者并行消费数据，支持轮询或随机策略。适用于消息吞吐量较大的业务场景，如邮件发送、日志记录等。
  - 串行消息：同一时刻只有一个消费者消费数据，消息按照生产顺序FIFO串行消费。适用于有串行消费诉求的业务场景，如秒杀、抢单等场景；
  - 分片消息：支持根据业务参数进行Hash分片，相同分片的消息数据路由至同一个消费者FIFO串行消费，不同分片的消息数据路由至不同消费者并行执行。适用于有根据业务参数分片消费的业务场景，如短信发送，可实现同一个手机号（业务参数）的消息路由至单个消费者串行消息，同时全局消息分片并行消费。
  - 广播消息：消息发送后，广播发送给相关主题全部在线消费者。适用于广播消息场景，如广播通知、广播更新缓存等；
  - 延时消息：支持设置消息的延迟生效时间，到达设置的生效时间时该消息才会被消费。适用于延时消费场景，如订单超时取消、定时发送邮件等；
  - 失败重试消息：支持设置消息的失败重试次数，自定义重试间隔侧路，消息失败时会主动进行重试消费，直至重试次数耗尽或者消费成功。
- 5、【增强】海量消息：消息存储基于DB实现，支持Mysql、TiDB多存储介质；消息存储进行冷热设计，并滚动式清理归档，支持海量消息堆积（Mysql存储支持千万级；TiDB存储支持10亿级/理论无上限）。
- 6、【新增】超时控制: 支持自定义消息超时时间，消息消费超时将会主动中断；
- 7、【新增】跨语言/OpenAPI：提供语言无关的消息中心 OpenAPI（RESTFUL 格式），提供消息生产、拉取及消费等能力，实现多语言支持；
- 8、【增强】易用性提升: 一行代码即可发布一条消息，一行注解即可订阅一个消息主题，接入灵活方便；
- 9、【增强】消息可视化: 提供消息中心Web控制台，可在线管理消息主题、消息数据，查看消费数据及消费轨迹等；
- 10、【新增】容器化：提供官方Docker镜像，并实时更新推送DockerHub，进一步实现产品开箱即用；

### v1.4.1 Release Notes[2025-07-20]
- 1、【增强】客户端新增消费者开关（xxl.mq.client.consumer.enabled），支持主动关闭客户端消费功能，针对只需要消息生产场景可降低系统资源损耗；
- 2、【优化】客户端SDK终止逻辑优化，避免启动失败时销毁异常；
- 3、【优化】客户端SDK消息校验逻辑优化，针对非法topic(长度>100)与非法数据(长度>4000)，主动输出错误日志、辅助快速定位业务问题；
- 4、【优化】消息失败告警巡检SQL问题修复；
- 5、【优化】注册实例清理SQL改为非别名方式，兼容Mysql8.0及以上版本；
- 6、【优化】升级多项依赖至较新版本；

### v1.5.0 特性[2025-08-16]
- 1、【升级】项目升级 SpringBoot3 + JDK17；
- 2、【升级】升级多项依赖至较新版本，如springboot、spring、jakarta等，适配JDK17；

### v1.5.1 Release Notes[迭代中]
- 1、【TODO】消费者线程优化：单消费者支持多线程并行消费；
- 2、【TODO】消息管理界面优化：支持 生效时间、新增时间 多种排序方式；


### TODO
- 考虑移除 mysql 强依赖的，迁移 jpa 进一步提升通用型。
- 客户端，Server端支持消息落磁盘；发送失败，存储失败时，写磁盘，避免消息丢失；LocalQueue消息可能丢失，考虑LocalFile；
- producer消息，生成UUID，推送失败重复推送，同时避免重复；
- 延迟消息方案优化：增加时间轮算法；
- 消息告警功能增强，目前仅支持失败告警，考虑支持消息堆积告警、阻塞告警等，Topic扩展属性存储阈值；30分钟统计一次消息情况, 将会根据topic分组, 堆积超过阈值的topic将会在报警邮件报表中进行记录;
- 消息主题界面，支持查看在线消费者列表；consumer：topic+group 在线展示；producer：在线展示；
- 优先级队列，环境属性。
- 超时消息处理：stuck消息，由标记“失败”改为标记“未消费”状态，可避免消费链路问题导致丢消息（现状，不会重复消费），但会导致小概率重复消费（需要实现幂等）；
- 消息等级：Topic优先级处理，拆分不同messagequeue；


## 七、其他

### 7.1 项目贡献
欢迎参与项目贡献！比如提交PR修复一个bug，或者新建 [Issue](https://github.com/xuxueli/xxl-mq/issues/) 讨论新特性或者变更。

### 7.2 用户接入登记
更多接入的公司，欢迎在 [登记地址](https://github.com/xuxueli/xxl-mq/issues/1 ) 登记，登记仅仅为了产品推广。

### 7.3 开源协议和版权
产品开源免费，并且将持续提供免费的社区技术支持。个人或企业内部可自由的接入和使用。

- Licensed under the GNU General Public License (GPL) v3.
- Copyright (c) 2015-present, xuxueli.

---
### 捐赠
无论金额多少都足够表达您这份心意，非常感谢 ：）      [前往捐赠](https://www.xuxueli.com/page/donate.html )
